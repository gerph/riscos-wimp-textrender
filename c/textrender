/*******************************************************************
 * File:        textrender
 * Purpose:     Rendering interface for the WindowManager
 * Author:      Gerph
 * Date:        11 Jan 2026
 ******************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>

#include "GContext/gcontext.h"
#include "textrender.h"
#include "textrender_nvram.h"
#include "wimpsymbol.h"

#define WIMP_FONTNAME_VAR "Wimp$Font"
#define WIMP_FONTSIZE_VAR "Wimp$FontSize"
#define WIMP_FONTWIDTH_VAR "Wimp$FontWidth"

#define WIMP_FONTXSIZE (12 * 16)
#define WIMP_FONTYSIZE (12 * 16)

#define DEFAULT_FG  (0xFFFFFF00u)
#define DEFAULT_BG  (0x00000000u)

typedef enum textdirection_e {
  td_lefttoright,
  td_righttoleft
} textdirection_t;

struct textrender_s {
    gcontext_t *gcontext;
    font_t font;
    font_t wimpsymbol;
    colour_t fg, bg;

    textdirection_t direction;
    int32_t ellipsis_width;
};


//#define DEBUG

#ifdef DEBUG
#define dprintf if (1) printf
#else
#define dprintf if (0) printf
#endif

#define IS_SYSTEM_FONT(trender) ((trender)->gcontext->text_readhandle((trender)->gcontext, (trender)->font) == 0)


/*************************************************** Gerph *********
 Function:      textrender_init
 Description:   Initialise the text rendering system
 Parameters:    gcontext-> the context we're using this render in
 Returns:       text rendering object, or NULL if failed
 ******************************************************************/
textrender_t *textrender_init(gcontext_t *gcontext)
{
    textrender_t *trender = calloc(sizeof(*trender), 1);
    if (trender == NULL)
        return trender;
    trender->gcontext = gcontext;
    trender->font = FONT_NONE;
    trender->fg = DEFAULT_FG;
    trender->bg = DEFAULT_BG;
    trender->wimpsymbol = FONT_NONE;
    trender->direction = td_lefttoright;
    return trender;
}

/*************************************************** Gerph *********
 Function:      textrender_readfont
 Description:   Read the font that should be used for this context
 Parameters:    trender-> the rendering context
                desktopfont-> where to populate the font to use
 Returns:       none
 ******************************************************************/
void textrender_readfont(textrender_t *trender, desktopfont_t *desktopfont)
{
    const char *fontname;
    const char *size;
    int32_t xsize = WIMP_FONTXSIZE;
    int32_t ysize = WIMP_FONTYSIZE;
    int font_config = textrender_getfontconfig(trender);

    if (font_config == FONT_CONFIG_WIMPFONT ||
        font_config == FONT_CONFIG_SYSTEMFONT)
    {
        if (font_config == FONT_CONFIG_SYSTEMFONT)
            fontname = NULL;
        else
            fontname = getenv(WIMP_FONTNAME_VAR);

        if (fontname == NULL)
        {
            desktopfont->fontname[0] = '\0';
            desktopfont->systemfont = true;
        }
        else
        {
            strncpy(desktopfont->fontname, fontname, sizeof(desktopfont->fontname));
            desktopfont->systemfont = false;
        }

        /* Determine font size */
        size = getenv(WIMP_FONTSIZE_VAR);
        if (size != NULL)
        {
            int value = atoi(size); /* Should this be an OS_ReadUnsigned? */
            if (value > 0 && value < 256*16)
            {
                xsize = value;
                ysize = value;
            }
        }
        size = getenv(WIMP_FONTWIDTH_VAR);
        if (size != NULL)
        {
            int value = atoi(size); /* Should this be an OS_ReadUnsigned? */
            if (value > 0 && value < 256*16)
            {
                xsize = value;
            }
        }
    }
    else
    {
        fontname = textrender_getromfontname(font_config);
        if (fontname == NULL)
        {
            desktopfont->fontname[0] = '\0';
            desktopfont->systemfont = false;
        }
        else
        {
            strncpy(desktopfont->fontname, fontname, sizeof(desktopfont->fontname));
            desktopfont->systemfont = false;
        }
    }

    desktopfont->xsize = xsize;
    desktopfont->ysize = ysize;
    dprintf("textrender_readfont(): %s, at %i x %i\n", desktopfont->systemfont ? "SYSTEM" : desktopfont->fontname,
                                                       desktopfont->xsize, desktopfont->ysize);
}


/*************************************************** Gerph *********
 Function:      textrender_setfont
 Description:   Set the font for the text rendering operations
 Parameters:    trender-> the rendering context
 Returns:       none
 ******************************************************************/
void textrender_setfont(textrender_t *trender)
{
    desktopfont_t dtf;
    textrender_readfont(trender, &dtf);
    if (trender->font != FONT_NONE)
    {
        trender->gcontext->text_losefont(trender->gcontext, trender->font);
        trender->font = FONT_NONE;
    }

    trender->font = trender->gcontext->text_findfont(trender->gcontext, dtf.systemfont ? "" : dtf.fontname, dtf.xsize, dtf.ysize);

    /* Setup the wimp symbol font */
    trender->wimpsymbol = trender->gcontext->text_findfont(trender->gcontext, "WimpSymbol", dtf.xsize, dtf.ysize);

#define ELLIPSIS_STRING "..."

    {
        stringbounds_t bounds;
        /* FIXME: Text direction is not taken account of */
        trender->gcontext->text_getstringsize(trender->gcontext, trender->font,
                                              &bounds, 0x7FFFFFFF,
                                              ELLIPSIS_STRING, strlen(ELLIPSIS_STRING), 0);
        trender->ellipsis_width = bounds.rbearing - bounds.lbearing;
    }
}


/*************************************************** Gerph *********
 Function:      textrender_convertlength
 Description:   Convert the length given to the actual byte count to use
 Parameters:    text-> the text string
                len = length supplied, either a number or TEXTRENDER_TERM0)
 Returns:       none
 ******************************************************************/
static int textrender_convertlength(const char *text, int len)
{
    switch (len)
    {
        case TEXTRENDER_TERM0:
            len = strlen(text);
            break;

        case TEXTRENDER_TERMCTRL:
            for (len = 0; *text >= ' '; text++)
                len++;
            break;

        default:
            if (len < 0)
                len = 0;
            break;
    }
    return len;
}


/*************************************************** Gerph *********
 Function:      textrender_setcolours
 Description:   Set the colours for the text rendering
 Parameters:    trender-> the rendering context
                bg, fg = the colours to use
 Returns:       none
 ******************************************************************/
void textrender_setcolours(textrender_t *trender, colour_t bg, colour_t fg)
{
    trender->bg = bg;
    trender->fg = fg;
}


/*************************************************** Gerph *********
 Function:      textrender_paint
 Description:   Draw some simple text
 Parameters:    trender-> the rendering context
                text-> string to render
                len = the length to render (or TEXTRENDER_TERM0 to use 0-terminated)
                x = position
                y = position
 Returns:       none
 ******************************************************************/
void textrender_paint(textrender_t *trender, const char *text, int len, int x, int y)
{
    const char *newtext = NULL;
    wimpsymbol_string_t wss;
    len = textrender_convertlength(text, len);

    if (! IS_SYSTEM_FONT(trender))
    {
        wss = wimpsymbol_convert(text, len,
                                 trender->gcontext->text_readhandle(trender->gcontext, trender->wimpsymbol),
                                 trender->gcontext->text_readhandle(trender->gcontext, trender->font));
        newtext = wss.string;
        text = wss.string;
        len = wss.len;
    }
    trender->gcontext->text_paint(trender->gcontext, trender->font,
                                  x, y, trender->bg, trender->fg,
                                  text, len);
    if (newtext)
        wimpsymbol_free(newtext);
}


/*************************************************** Gerph *********
 Function:      textrender_stringwidth
 Description:   Read the width of a string on screen (Wimp_TextOp 1-like)
 Parameters:    trender-> the rendering context
                text-> string to size, ctrl terminated)
                len = the length of the string (or TEXTRENDER_TERM0 for 0-termination)
 Returns:       the width in OS units
 ******************************************************************/
int32_t textrender_stringwidth(textrender_t *trender, const char *text, int len)
{
    int32_t width;
    stringbounds_t bounds;
    len = textrender_convertlength(text, len);

    {
        const char *newtext = NULL;
        wimpsymbol_string_t wss;
        if (! IS_SYSTEM_FONT(trender))
        {
            wss = wimpsymbol_convert(text, len,
                                     trender->gcontext->text_readhandle(trender->gcontext, trender->wimpsymbol),
                                     trender->gcontext->text_readhandle(trender->gcontext, trender->font));
            newtext = wss.string;
            text = wss.string;
            len = wss.len;
        }
        trender->gcontext->text_getstringsize(trender->gcontext, trender->font,
                                              &bounds, 0x7FFFFFFF,
                                              text, len, GCONTEXT_NOSPLIT);
        if (bounds.rbearing > bounds.xoffset)
            width = bounds.rbearing;
        else
            width = bounds.xoffset;
        if (newtext)
            wimpsymbol_free(newtext);
    }

    return width;
}

/*************************************************** Gerph *********
 Function:      textrender_stringwidthwithsplit
 Description:   Work out the split point for a string with a width
 Parameters:    trender-> the rendering context
                text-> string to size, ctrl terminated)
                len = the length of the string (or TEXTRENDER_TERM0 for 0-termination)
                width = the width to split at
                splitchar = character to split on (or TEXTRENDER_NOSPLIT for none)
 Returns:       split point pointer within the text string.
 ******************************************************************/
const char *textrender_stringwidthwithsplit(textrender_t *trender, const char *text, int len, int32_t width, int splitchar)
{
    const char *splitpoint;
    stringbounds_t bounds;
    len = textrender_convertlength(text, len);
    dprintf("textrender_stringwidthwithsplit: text='%s', len=%i, split = %i\n", text, len, splitchar);

    {
        const char *newtext = NULL;
        wimpsymbol_string_t wss;
        if (! IS_SYSTEM_FONT(trender))
        {
            /* FIXME Length not handled in symbol conversion */
            wss = wimpsymbol_convert(text, len,
                                     trender->gcontext->text_readhandle(trender->gcontext, trender->wimpsymbol),
                                     trender->gcontext->text_readhandle(trender->gcontext, trender->font));
            newtext = wss.string;
            text = wss.string;
            len = wss.len;
        }
        trender->gcontext->text_getstringsize(trender->gcontext, trender->font,
                                              &bounds, width,
                                              text, len, (splitchar == TEXTRENDER_NOSPLIT) ? GCONTEXT_NOSPLIT : splitchar);
        if (bounds.rbearing > bounds.xoffset)
            width = bounds.rbearing;
        else
            width = bounds.xoffset;

        dprintf("  character offset = %i\n", bounds.charoffset);
        splitpoint = text + bounds.charoffset;

        if (newtext)
            wimpsymbol_free(newtext);
    }

    return splitpoint;
}
